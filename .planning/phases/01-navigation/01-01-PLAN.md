---
phase: 01-navigation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/app/[locale]/plan/use-plan-page.ts
  - apps/web/app/[locale]/plan/page.tsx
autonomous: false

must_haves:
  truths:
    - "User zooms in on a poster and the zoom centers on their cursor position, not the canvas origin"
    - "User can pan smoothly across the entire canvas without getting stuck"
    - "User clicks Reset and all posters appear centered in the viewport"
    - "Zoom and pan work consistently across different poster positions on the canvas"
  artifacts:
    - path: "apps/web/app/[locale]/plan/use-plan-page.ts"
      provides: "Cursor-centered zoom, smooth pan, dynamic resetView"
      contains: "scaleRatio"
    - path: "apps/web/app/[locale]/plan/page.tsx"
      provides: "Canvas container with ref for resetView bounds calculation"
      contains: "containerRef"
  key_links:
    - from: "onWheel handler"
      to: "offset + scale state"
      via: "cursor-centered zoom formula: newOffset = cursor - (cursor - oldOffset) * (newScale / oldScale)"
      pattern: "viewportX.*viewportY.*scaleRatio"
    - from: "resetView function"
      to: "boards array + container dimensions"
      via: "getBounds calculates content extent, fitScale fits to viewport"
      pattern: "getBoundingClientRect|getBounds"
    - from: "page.tsx CanvasSection"
      to: "use-plan-page.ts containerRef"
      via: "ref passed from component to hook for viewport measurement"
      pattern: "containerRef"
---

<objective>
Fix the Plan page zoom and pan to feel like navigating a physical space (Figma/Miro style).

Purpose: The Plan page is the spatial heart of MADMall -- users explore posters laid out on an infinite canvas. Currently, zoom snaps to the canvas origin instead of the cursor, and the Reset button uses hardcoded offsets instead of calculating content bounds. This breaks the "walking through a mall" feeling.

Output: Working cursor-centered zoom, existing smooth pan (unchanged), and a dynamic Reset View button that centers all posters in the viewport.
</objective>

<execution_context>
@/Users/coreyalejandro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/coreyalejandro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-navigation/01-RESEARCH.md

@apps/web/app/[locale]/plan/use-plan-page.ts
@apps/web/app/[locale]/plan/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix cursor-centered zoom in onWheel</name>
  <files>apps/web/app/[locale]/plan/use-plan-page.ts</files>
  <action>
Replace the `onWheel` function in `usePlanPage()` hook. The current implementation only calls `setScale` without adjusting `offset`, causing zoom to center on the canvas origin.

The fix uses the cursor-centered zoom formula from RESEARCH.md:
```
newOffset = cursor - (cursor - oldOffset) * (newScale / oldScale)
```

Implementation:

1. The `onWheel` function currently receives `event: React.WheelEvent<HTMLDivElement>` -- keep that signature.

2. Replace the body with:
   - Call `event.preventDefault()` (already present)
   - Get cursor position in viewport coordinates using `event.currentTarget.getBoundingClientRect()` and `event.clientX/Y - rect.left/top`. Do NOT use `event.offsetX/Y` (it's relative to event target, not container, so hovering over child poster elements would give wrong coordinates).
   - Calculate `newScale` using the existing clamped formula: `clamp(scale * factor, 0.4, 2.2)` where factor is `delta > 0 ? 1.07 : 0.93`. Calculate newScale FIRST, then use the clamped value for offset calculation (Pitfall 3 from research).
   - Calculate `scaleRatio = newScale / scale`
   - Set offset: `{ x: viewportX - (viewportX - offset.x) * scaleRatio, y: viewportY - (viewportY - offset.y) * scaleRatio }`
   - Set scale to `newScale`

3. IMPORTANT: The `onWheel` currently uses the `setScale(s => ...)` callback form, but we need the current `scale` value for the offset calculation. The hook already has `scale` in scope as state, so read `scale` directly (not via callback). Set both `offset` and `scale` as direct state updates (not callbacks). This ensures the offset and scale are computed together from the same values.

4. Do NOT change the pan handlers (`onPointerDown`, `onPointerMove`, `onPointerUp`) -- the research confirms they're already correct.

5. Do NOT change the `transformStyle` memo, the `clamp` utility, or any other part of the hook.
  </action>
  <verify>
Run `pnpm --filter web build` (or `pnpm turbo build --filter=web`) to confirm the file compiles without TypeScript errors. Manually inspect the onWheel function to confirm it uses `getBoundingClientRect()`, calculates `scaleRatio`, and sets both offset and scale.
  </verify>
  <done>
The `onWheel` function calculates cursor position via `getBoundingClientRect()`, computes `scaleRatio = newScale / scale`, and sets offset using `viewportX - (viewportX - offset.x) * scaleRatio` pattern. Scale is clamped before offset calculation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix resetView to calculate content bounds and fit to viewport</name>
  <files>
    apps/web/app/[locale]/plan/use-plan-page.ts
    apps/web/app/[locale]/plan/page.tsx
  </files>
  <action>
The current `resetView` function uses hardcoded values `{ x: -200, y: -150 }` and `scale: 1`. Replace it with a dynamic calculation that finds the bounding box of all boards and fits them into the viewport with padding.

**In `use-plan-page.ts`:**

1. Add a `containerRef = useRef<HTMLDivElement>(null)` inside the `usePlanPage` hook. This ref will be attached to the viewport container div in `page.tsx`.

2. Add a pure helper function `getBounds` OUTSIDE the hook (near the `clamp` function):
```typescript
function getBounds(boards: PlanBoard[]) {
  if (boards.length === 0) {
    return { minX: 0, minY: 0, maxX: 0, maxY: 0 };
  }
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  for (const b of boards) {
    minX = Math.min(minX, b.x);
    minY = Math.min(minY, b.y);
    maxX = Math.max(maxX, b.x + b.w);
    maxY = Math.max(maxY, b.y + b.h);
  }
  return { minX, minY, maxX, maxY };
}
```

3. Replace the `resetView` function body:
   - If `boards.length === 0`, set offset to `{ x: 0, y: 0 }` and scale to `1`, then return.
   - Get container dimensions via `containerRef.current?.getBoundingClientRect()`. If no container ref, fall back to `{ x: 0, y: 0 }` and scale `1`.
   - Call `getBounds(boards)` to get content bounds.
   - Calculate `contentWidth = maxX - minX` and `contentHeight = maxY - minY`.
   - Calculate padding of 40px on each side.
   - Calculate `scaleX = (rect.width - 80) / contentWidth` and `scaleY = (rect.height - 80) / contentHeight`.
   - Calculate `fitScale = Math.min(scaleX, scaleY, 1)` -- the `1` cap prevents zooming in beyond 100% when content is small.
   - Calculate center offset: `x = rect.width / 2 - (minX + contentWidth / 2) * fitScale` and `y = rect.height / 2 - (minY + contentHeight / 2) * fitScale`.
   - Set scale and offset.

4. Add `containerRef` to the return object of the hook.

**In `page.tsx`:**

5. In the `usePlanPage()` destructuring at the top of `PlanPage`, add `containerRef` (it's not currently destructured because it doesn't exist yet).

6. Pass `containerRef` as a prop to the `CanvasSection` component.

7. In the `CanvasSection` component:
   - Add `containerRef: React.RefObject<HTMLDivElement | null>` to the props type.
   - Attach `ref={containerRef}` to the inner div (the one with `className="relative h-full w-full overflow-hidden"` that has the pointer/wheel handlers). This is the viewport container -- the element whose dimensions represent the visible area.

Do NOT change the `BoardPoster`, `ListSection`, or `DocSection` components.
  </action>
  <verify>
Run `pnpm --filter web build` (or `pnpm turbo build --filter=web`) to confirm both files compile without TypeScript errors. Inspect `resetView` to confirm it calls `getBounds`, uses `containerRef.current?.getBoundingClientRect()`, and calculates `fitScale` with a `Math.min(..., 1)` cap. Inspect `page.tsx` to confirm `containerRef` is passed to and attached in `CanvasSection`.
  </verify>
  <done>
`resetView` dynamically calculates board bounds via `getBounds()`, measures the viewport via `containerRef`, computes a `fitScale` that fits all posters with 40px padding (capped at 1x), and centers the content. The container ref is wired from the hook through `PlanPage` to the viewport div in `CanvasSection`.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Cursor-centered zoom (Figma/Miro style) and dynamic Reset View for the Plan page canvas.</what-built>
  <how-to-verify>
1. Start the dev server: `pnpm dev` (or `pnpm --filter web dev`)
2. Navigate to the Plan page (e.g., http://localhost:3000/en/plan or whatever your locale route is)
3. **Test cursor-centered zoom (NAV-01):**
   - Hover your cursor over a poster on the LEFT side of the canvas
   - Scroll up (zoom in) -- the zoom should center on your cursor, keeping the poster under it stationary
   - Scroll down (zoom out) -- same behavior, the point under your cursor stays put
   - Move your cursor to a poster on the RIGHT side and repeat -- zoom should center on THAT position now
   - Compare: previously, zooming always pulled toward the top-left origin regardless of cursor position
4. **Test pan (NAV-02, should be unchanged):**
   - Click and drag on the canvas background -- panning should feel smooth
   - Drag across different areas -- no "sticky" corners or dead zones
   - Release -- panning stops cleanly
5. **Test Reset View (NAV-03):**
   - Zoom in deeply on one poster, then pan far away from center
   - Click the "Reset" button in the top-right toolbar
   - All posters should appear centered in the viewport with some padding around them
   - The zoom level should be at most 1x (100%) -- if all posters fit at smaller zoom, it should use that
6. **Test consistency (NAV success criterion 4):**
   - Zoom into different posters at different positions on the canvas
   - Each time, the zoom should feel the same: smooth, cursor-centered, no jumping
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues with zoom, pan, or reset behavior.</resume-signal>
</task>

</tasks>

<verification>
- TypeScript compilation: `pnpm --filter web build` passes with no errors
- onWheel uses `getBoundingClientRect()` and cursor-centered formula (grep for `scaleRatio` in use-plan-page.ts)
- resetView uses `getBounds` and `containerRef` (grep for `getBounds` and `containerRef` in use-plan-page.ts)
- containerRef wired through page.tsx (grep for `containerRef` in page.tsx)
- Pan handlers unchanged (diff should show no changes to onPointerDown/Move/Up)
</verification>

<success_criteria>
1. Zooming in/out on the Plan page centers on the cursor position, not the canvas origin
2. Panning works smoothly across the entire canvas (unchanged from current behavior)
3. Clicking Reset centers all posters in the viewport with appropriate padding and zoom level
4. TypeScript compiles without errors
5. No new dependencies added
</success_criteria>

<output>
After completion, create `.planning/phases/01-navigation/01-01-SUMMARY.md`
</output>
